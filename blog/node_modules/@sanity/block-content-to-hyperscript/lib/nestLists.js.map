{"version":3,"sources":["../src/nestLists.js"],"names":["objectAssign","require","nestLists","blocks","mode","tree","currentList","i","length","block","isListBlock","push","listFromBlock","blockMatchesList","children","level","newList","lastListItem","lastChild","newLastChild","concat","match","findListMatching","listItem","console","warn","Boolean","list","_type","_key","rootNode","matching","filterOnType","node","module","exports"],"mappings":"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","file":"nestLists.js","sourcesContent":["const objectAssign = require('object-assign')\n\n/* eslint-disable max-depth, complexity */\nfunction nestLists(blocks, mode = 'html') {\n  const tree = []\n  let currentList\n\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i]\n    if (!isListBlock(block)) {\n      tree.push(block)\n      currentList = null\n      continue\n    }\n\n    // Start of a new list?\n    if (!currentList) {\n      currentList = listFromBlock(block)\n      tree.push(currentList)\n      continue\n    }\n\n    // New list item within same list?\n    if (blockMatchesList(block, currentList)) {\n      currentList.children.push(block)\n      continue\n    }\n\n    // Different list props, are we going deeper?\n    if (block.level > currentList.level) {\n      const newList = listFromBlock(block)\n\n      if (mode === 'html') {\n        // Because HTML is kinda weird, nested lists needs to be nested within list items\n        // So while you would think that we could populate the parent list with a new sub-list,\n        // We actually have to target the last list element (child) of the parent.\n        // However, at this point we need to be very careful - simply pushing to the list of children\n        // will mutate the input, and we don't want to blindly clone the entire tree.\n\n        // Clone the last child while adding our new list as the last child of it\n        const lastListItem = lastChild(currentList)\n        const newLastChild = objectAssign({}, lastListItem, {\n          children: lastListItem.children.concat(newList)\n        })\n\n        // Swap the last child\n        currentList.children[currentList.children.length - 1] = newLastChild\n      } else {\n        currentList.children.push(newList)\n      }\n\n      // Set the newly created, deeper list as the current\n      currentList = newList\n      continue\n    }\n\n    // Different list props, are we going back up the tree?\n    if (block.level < currentList.level) {\n      // Current list has ended, and we need to hook up with a parent of the same level and type\n      const match = findListMatching(tree[tree.length - 1], block)\n      if (match) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      }\n\n      // Similar parent can't be found, assume new list\n      currentList = listFromBlock(block)\n      tree.push(currentList)\n      continue\n    }\n\n    // Different list props, different list style?\n    if (block.listItem !== currentList.listItem) {\n      const match = findListMatching(tree[tree.length - 1], {level: block.level})\n      if (match && match.listItem === block.listItem) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      } else {\n        currentList = listFromBlock(block)\n        tree.push(currentList)\n        continue\n      }\n    }\n\n    // eslint-disable-next-line no-console\n    console.warn('Unknown state encountered for block', block)\n    tree.push(block)\n  }\n\n  return tree\n}\n\nfunction isListBlock(block) {\n  return Boolean(block.listItem)\n}\n\nfunction blockMatchesList(block, list) {\n  return block.level === list.level && block.listItem === list.listItem\n}\n\nfunction listFromBlock(block) {\n  return {\n    _type: 'list',\n    _key: `${block._key}-parent`,\n    level: block.level,\n    listItem: block.listItem,\n    children: [block]\n  }\n}\n\nfunction lastChild(block) {\n  return block.children && block.children[block.children.length - 1]\n}\n\nfunction findListMatching(rootNode, matching) {\n  const filterOnType = typeof matching.listItem === 'string'\n  if (\n    rootNode._type === 'list' &&\n    rootNode.level === matching.level &&\n    (filterOnType && rootNode.listItem === matching.listItem)\n  ) {\n    return rootNode\n  }\n\n  const node = lastChild(rootNode)\n  if (!node) {\n    return false\n  }\n\n  return findListMatching(node, matching)\n}\n\nmodule.exports = nestLists\n"]}