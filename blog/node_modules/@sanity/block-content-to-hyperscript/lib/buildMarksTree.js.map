{"version":3,"sources":["../src/buildMarksTree.js"],"names":["defaultMarks","buildMarksTree","children","block","markDefs","length","sortedMarks","map","sortMarksByOccurences","rootNode","_type","nodeStack","forEach","span","i","marksNeeded","lastNode","push","pos","mark","markKey","index","indexOf","splice","slice","currentNode","findLastParentNode","node","_key","find","def","isTextSpan","lines","text","split","line","concat","spans","marks","markOccurences","reduce","occurences","siblingIndex","sibling","Array","isArray","sortByOccurence","sortMarks","bind","sort","markA","markB","aOccurences","bOccurences","aDefaultPos","bDefaultPos","nodes","undefined","module","exports"],"mappings":"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","file":"buildMarksTree.js","sourcesContent":["const defaultMarks = ['strong', 'em', 'code', 'underline', 'strike-through']\n\nconst buildMarksTree = block => {\n  const {children, markDefs} = block\n  if (!children || !children.length) {\n    return []\n  }\n\n  const sortedMarks = children.map(sortMarksByOccurences)\n  const rootNode = {_type: 'span', children: []}\n  let nodeStack = [rootNode]\n\n  children.forEach((span, i) => {\n    const marksNeeded = sortedMarks[i]\n    if (!marksNeeded) {\n      const lastNode = nodeStack[nodeStack.length - 1]\n      lastNode.children.push(span)\n      return\n    }\n\n    let pos = 1\n\n    // Start at position one. Root is always plain and should never be removed. (?)\n    if (nodeStack.length > 1) {\n      for (pos; pos < nodeStack.length; pos++) {\n        const mark = nodeStack[pos].markKey\n        const index = marksNeeded.indexOf(mark)\n        // eslint-disable-next-line max-depth\n        if (index === -1) {\n          break\n        }\n\n        marksNeeded.splice(index, 1)\n      }\n    }\n\n    // Keep from beginning to first miss\n    nodeStack = nodeStack.slice(0, pos)\n\n    // Add needed nodes\n    let currentNode = findLastParentNode(nodeStack)\n    marksNeeded.forEach(mark => {\n      const node = {\n        _type: 'span',\n        _key: span._key,\n        children: [],\n        mark: markDefs.find(def => def._key === mark) || mark,\n        markKey: mark\n      }\n\n      currentNode.children.push(node)\n      nodeStack.push(node)\n      currentNode = node\n    })\n\n    // Split at newlines to make individual line chunks, but keep newline\n    // characters as individual elements in the array. We use these characters\n    // in the span serializer to trigger hard-break rendering\n    if (isTextSpan(span)) {\n      const lines = span.text.split('\\n')\n      for (let line = lines.length; line-- > 1; ) {\n        lines.splice(line, 0, '\\n')\n      }\n\n      currentNode.children = currentNode.children.concat(lines)\n    } else {\n      currentNode.children = currentNode.children.concat(span)\n    }\n  })\n\n  return rootNode.children\n}\n\n// We want to sort all the marks of all the spans in the following order:\n// 1. Marks that are shared amongst the most adjacent siblings\n// 2. Non-default marks (links, custom metadata)\n// 3. Built-in, plain marks (bold, emphasis, code etc)\nfunction sortMarksByOccurences(span, i, spans) {\n  if (!span.marks || span.marks.length === 0) {\n    return span.marks || []\n  }\n\n  const markOccurences = span.marks.reduce((occurences, mark) => {\n    occurences[mark] = occurences[mark] ? occurences[mark] + 1 : 1\n\n    for (let siblingIndex = i + 1; siblingIndex < spans.length; siblingIndex++) {\n      const sibling = spans[siblingIndex]\n\n      if (sibling.marks && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) {\n        occurences[mark]++\n      } else {\n        break\n      }\n    }\n\n    return occurences\n  }, {})\n\n  const sortByOccurence = sortMarks.bind(null, markOccurences)\n\n  // Slicing because sort() mutates the input\n  return span.marks.slice().sort(sortByOccurence)\n}\n\nfunction sortMarks(occurences, markA, markB) {\n  const aOccurences = occurences[markA] || 0\n  const bOccurences = occurences[markB] || 0\n\n  if (aOccurences !== bOccurences) {\n    return bOccurences - aOccurences\n  }\n\n  const aDefaultPos = defaultMarks.indexOf(markA)\n  const bDefaultPos = defaultMarks.indexOf(markB)\n\n  // Sort default marks last\n  if (aDefaultPos !== bDefaultPos) {\n    return aDefaultPos - bDefaultPos\n  }\n\n  // Sort other marks simply by key\n  if (markA < markB) {\n    return -1\n  } else if (markA > markB) {\n    return 1\n  }\n\n  return 0\n}\n\nfunction isTextSpan(node) {\n  return (\n    node._type === 'span' &&\n    typeof node.text === 'string' &&\n    (Array.isArray(node.marks) || typeof node.marks === 'undefined')\n  )\n}\n\nfunction findLastParentNode(nodes) {\n  for (let i = nodes.length - 1; i >= 0; i--) {\n    const node = nodes[i]\n    if (node._type === 'span' && node.children) {\n      return node\n    }\n  }\n\n  return undefined\n}\n\nmodule.exports = buildMarksTree\n"]}